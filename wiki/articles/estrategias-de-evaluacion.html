<!DOCTYPE html>
<!--[if IE 9]>
<html class="lt-ie10" lang="en" prefix="og: http://ogp.me/ns#"> <![endif]-->
<html class="no-js" lang="en" prefix="og: http://ogp.me/ns#">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    


  <title>Estrategias de evaluacion</title>
  <meta property="og:title" content="Estrategias de evaluacion" />






<link rel="canonical" href="uqbar-project.github.io/wiki/articles/estrategias-de-evaluacion.html" />
<meta property="og:url" content="uqbar-project.github.io/wiki/articles/estrategias-de-evaluacion.html" />
<meta property="og:site_name" content="uqbar-wiki" />
<meta name="application-name" content="uqbar-wiki"/>

<meta property="og:updated_time" content=" 2017-02-09T11:53:29-03:00" />






  <meta property="keywords" content="" />











    <link rel="shortcut icon" type="image/x-icon" href="/wiki/favicon.ico" >
    <link type="text/plain" rel="author" href="/wiki/humans.txt"/>

    <link rel="stylesheet" href="/wiki/assets/app-ce8dd519ee762abf28c16f11faacee90.css">
    <style>
        .navbar {
            -webkit-backface-visibility: hidden;
        }
    </style>
</head>

<body>

<nav class="top-bar" data-topbar>
    <ul class="title-area">
        <li class="name">
            <div id="pagetitle"><a href="/wiki/">uqbar-wiki</a></div>
        </li>
        <!-- Remove the class "menu-icon" to get rid of menu icon. Take out "Menu" to just have icon alone -->
        <li class="toggle-topbar menu-icon"><a href="#"><span>Menu</span></a></li>
    </ul>

    <div class="top-bar-section">
        <!-- Right Nav Section -->
        <ul class="right">
            <li class="has-dropdown">
                <a href="#">Help</a>
                <ul class="dropdown">
                    <li><a class="link article_link" href="/wiki/wiki/articles/Frequently-Asked-Questions.html">Frequently Asked Questions</a></li>
                    <li><a class="link article_link" href="/wiki/wiki/articles/como-empezar.html">como-empezar</a></li>
                </ul>
            </li>
        </ul>

        <!-- Left Nav Section -->
        <ul class="left">
            <li class="has-dropdown">
                <a href="#">Navigation</a>
                <ul class="dropdown">
                    <li><a class="link article_link" href="/wiki/wiki/articles/paradigma-de-programacion.html">paradigma de programacion</a></li>
                    <li><a class="link article_link" href="/wiki/wiki/articles/design-temario.html">design temario</a></li>
                    <li><a class="link article_link" href="/wiki/wiki/articles/tecnicas-avanzadas-de-programacion.html">tecnicas avanzadas de programacion</a></li>
                    <li><a class="link article_link" href="/wiki/wiki/articles/programacion-de-interfaces-de-usuario.html">programacion de interfaces de usuario</a></li>
                    <li><a class="link article_link" href="/wiki/wiki/articles/algo3-temario.html">algo3 temario</a></li>
                    <li><a class="link article_link" href="/wiki/wiki/articles/programacion-con-herramientas-modernas.html">programacion con herramientas modernas</a></li>
                </ul>
            </li>
        </ul>
    </div>

</nav>

<div class="column small-0 medium-2 large-2 sidebar" style="margin-top: 10px;">
    <div class="rows">
        <img src="/wiki/img/uqbar_logo.png">
    </div>

    <ul class="rows small-12 medium-10 large-10 side-nav stack button-group" title="Link List" role="menu">
        <li class="button" role="menuitem"><a href="/wiki/">Home</a></li>
        <li class="button" role="menuitem"><a href="/wiki/articles">Lista de articulos</a></li>
    </ul>
</div>

<div class="column small-12 medium-10 large-10">
    <div id="article_title">
    <h1>
        Estrategias de evaluacion
    </h1>
</div>

<div id="article_content">
    <div id="toc-container">
  <table class="toc" id="toc">
    <tbody>
      <tr>
        <td>
          <div id="toctitle">
            <h2>Contents</h2>
          </div>
          <ul>
            <li class="toc_level-1 toc_section-1">
              <a href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">Introducción</span></a>
            </li>
            <li class="toc_level-1 toc_section-2">
              <a href="#tocAnchor-1-2"><span class="tocnumber">2</span> <span class="toctext">Primer ejemplo</span></a>
            </li>
            <li class="toc_level-1 toc_section-3">
              <a href="#tocAnchor-1-3"><span class="tocnumber">3</span> <span class="toctext">Estrategias básicas</span></a>
              <ul>
                <li class="toc_level-2 toc_section-4">
                  <a href="#tocAnchor-1-3-1"><span class="tocnumber">3.1</span> <span class="toctext">De adentro hacia afuera</span></a>
                </li>
                <li class="toc_level-2 toc_section-5">
                  <a href="#tocAnchor-1-3-2"><span class="tocnumber">3.2</span> <span class="toctext">De afuera hacia adentro</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-6">
              <a href="#tocAnchor-1-6"><span class="tocnumber">4</span> <span class="toctext">Evaluaciones que no terminan</span></a>
            </li>
            <li class="toc_level-1 toc_section-7">
              <a href="#tocAnchor-1-7"><span class="tocnumber">5</span> <span class="toctext">Lazy Evaluation</span></a>
              <ul>
                <li class="toc_level-2 toc_section-8">
                  <a href="#tocAnchor-1-7-1"><span class="tocnumber">5.1</span> <span class="toctext">Visión técnica</span></a>
                </li>
                <li class="toc_level-2 toc_section-9">
                  <a href="#tocAnchor-1-7-2"><span class="tocnumber">5.2</span> <span class="toctext">Visión operativa</span></a>
                </li>
                <li class="toc_level-2 toc_section-10">
                  <a href="#tocAnchor-1-7-3"><span class="tocnumber">5.3</span> <span class="toctext">Estructuras infinitas</span></a>
                </li>
                <li class="toc_level-2 toc_section-11">
                  <a href="#tocAnchor-1-7-4"><span class="tocnumber">5.4</span> <span class="toctext">Listas infinitas</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-12">
              <a href="#tocAnchor-1-12"><span class="tocnumber">6</span> <span class="toctext">Ejemplos</span></a>
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
</div><h2 id="estrategias-de-evaluación">Estrategias de evaluación</h2>

<h1 id="tocAnchor-1-1">Introducción</h1>

<p>La operación que realizamos en funcional es aplicar funciones, la idea del tema que vamos a tratar a continuación es saber qué se tiene que tener en cuenta para determinar el orden en en que aplicarán las funciones de una expresión.</p>

<h1 id="tocAnchor-1-2">Primer ejemplo</h1>

<p>
  <code class="highlighter-rouge">  masUno x = x + 1</code>
</p>

<p>La expresión masUno (2*3) puede ser evaluada de la siguiente forma</p>

<p>
  <code class="highlighter-rouge">  masUno (2*3)</code>
</p>

<ul>
  <li>aplicamos *</li>
</ul>

<p>
  <code class="highlighter-rouge">  masUno 6</code>
</p>

<ul>
  <li>aplicamos masUno</li>
</ul>

<p>
  <code class="highlighter-rouge">  6 + 1</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge">  7</code>
</p>

<p>Alternativamente podemos evaluar la misma expresión pero aplicando las funciones en el orden inverso</p>

<p>
  <code class="highlighter-rouge">  masUno (2*3)</code>
</p>

<ul>
  <li>aplicamos masUno</li>
</ul>

<p>
  <code class="highlighter-rouge">  (2*3) + 1</code>
</p>

<ul>
  <li>aplicamos *</li>
</ul>

<p>
  <code class="highlighter-rouge">  6 + 1</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge">  7</code>
</p>

<p>No importa el orden en que apliquemos las funciones vamos a llegar al mismo resultado final. Esto no solo vale para ejemplos sencillos sino que se cumple siempre en Haskell.</p>

<p>Esta propiedad no se cumple en la mayoría de los “lenguajes imperativos” (Pascal, C, Smalltalk, Java, C#, etc.), veamos un ejemplo en Smalltalk:</p>

<p>Si tenemos la expresión n + (n := 1) y n empieza apuntando a 0.</p>

<p>Si empezamos a evaluar de izquierda a derecha</p>

<p>
  <code class="highlighter-rouge"> n + (n := 1)</code>
</p>

<ul>
  <li>aplicamos n</li>
</ul>

<p>
  <code class="highlighter-rouge"> 0 + (n := 1)</code>
</p>

<ul>
  <li>aplicamos :=</li>
</ul>

<p>
  <code class="highlighter-rouge"> 0 + 1</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1</code>
</p>

<p>Si empezamos a evaluar de derecha a izquierda</p>

<p>
  <code class="highlighter-rouge"> n + (n:= 1)</code>
</p>

<ul>
  <li>aplicamos :=</li>
</ul>

<p>
  <code class="highlighter-rouge"> n + 1</code>
</p>

<ul>
  <li>aplicamos n</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 + 1</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge"> 2</code>
</p>

<p>Como se puede observar, si evaluamos las expresiones con distintas estrategias obtenemos resultados distintos; esto sucede porque las operaciones involucradas no tienen <a href="transparencia-referencial--efecto-de-lado-y-asignacion-destructiva.html"> transparencia referencial</a> en este caso particular debido a la introducción de una <a href="transparencia-referencial--efecto-de-lado-y-asignacion-destructiva.html"> asignación destructiva</a>.</p>

<h1 id="tocAnchor-1-3">Estrategias básicas</h1>

<p>A una expresión que consta de una función aplicada a uno o más parámetros y que puede ser “reducida” aplicando dicha función la vamos a llamar Redex (Reducible Expression). Se le dice reducción al hecho de aplicar la función no necesariamente vamos a obtener una expresión “más corta” como veremos más adelante. Consideremos la función mult que tiene como dominio una tupla de 2 números</p>

<p>
  <code class="highlighter-rouge"> mult (x,y) = x * y</code>
</p>

<p>Si queremos reducir la expresión mult (1+2,2+3) está expresión contiene 3 redexs</p>

<ul>
  <li>
    <ol>
      <li>1+2 (la función + aplicada a 2 parámetros)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>2+3 (la función + aplicada a 2 parámetros)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>mult (1+2,2+3) (la función mult aplicada a 1 parámetro que es una tupla)</li>
    </ol>
  </li>
</ul>

<p>Si queremos evaluar la expresión ¿qué estrategia usamos?</p>

<h2 id="tocAnchor-1-3-1">De adentro hacia afuera</h2>

<p>También conocida como call-by-value</p>

<p>Una de las estrategias más comunes es comenzar desde adentro hacia afuera (innermost evaluation), esta estrategia elige el redex que está “más adentro” entendiendo por esto al redex que no contiene otro redex. Si existe más de un redex que cumple dicha condición se elige el que está más a la izquierda. Vamos al ejemplo</p>

<p>
  <code class="highlighter-rouge"> mult (1+2,2+3)</code>
</p>

<ul>
  <li>aplicamos el primer +</li>
</ul>

<p>
  <code class="highlighter-rouge"> mult (3,2+3)</code>
</p>

<ul>
  <li>aplicamos el +</li>
</ul>

<p>
  <code class="highlighter-rouge"> mult (3,5)</code>
</p>

<ul>
  <li>aplicamos mult</li>
</ul>

<p>
  <code class="highlighter-rouge"> 3 * 5</code>
</p>

<ul>
  <li>aplicamos *</li>
</ul>

<p>
  <code class="highlighter-rouge"> 15</code>
</p>

<p>Esta estrategia me asegura que los parámetros de una función están completamente evaluados antes de que la función sea aplicada. Por eso se dice que los parámetros se pasan por valor.</p>

<h2 id="tocAnchor-1-3-2">De afuera hacia adentro</h2>

<p>También conocida como call-by-name</p>

<p>Otra de las estrategias más comunes es comenzar desde afuera hacia adentro (outtermost evaluation), esta estrategia elige el redex que está “más afuera” entendiendo por esto al redex que no esta contenido en otro redex. Si existe más de un redex que cumple dicha condición se elige el que está más a la izquierda. Vamos al ejemplo</p>

<p>mult (1+2,2+3)</p>

<ul>
  <li>aplicamos mult</li>
</ul>

<p>
  <code class="highlighter-rouge"> (1+2) * (2+3)</code>
</p>

<ul>
  <li>aplicamos el primer + (Si seguimos lo que dijimos arriba deberíamos aplicar primero el * pero vamos a explicar porque no lo hacemos más abajo)</li>
</ul>

<p>
  <code class="highlighter-rouge">  3 * (2+3)</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge">  3 * 5</code>
</p>

<ul>
  <li>aplicamos *</li>
</ul>

<p>
  <code class="highlighter-rouge">  15</code>
</p>

<p>Usando esta estrategia las funciones se aplican antes que los parámetros sean evaluados. Por esto se dice que los parámetros se pasan por nombre. Nota: Hay que tener en cuenta que muchas funciones que ya vienen con Haskell requieren que sus parámetros estén evaluados antes de que la función sea aplicada, incluso cuando usamos la estrategia “de afuera hacia adentro”. Por ejemplo, el operador * y el + no pueden ser aplicados hasta que sus dos parámetros hayan sido evaluados a números. A las funciones que cumplen con esta propiedad las vamos a llamar funciones estrictas. Funciones estrictas que nos van a interesar a nosotros:</p>

<ul>
  <li>Operaciones aritméticas (+,*,/,etc.)</li>
  <li>Pattern-Matching (sobre listas, tuplas, etc.)</li>
</ul>

<h1 id="tocAnchor-1-6">Evaluaciones que no terminan</h1>

<p>Tengan en cuenta la siguiente definición</p>

<p>
  <code class="highlighter-rouge"> inf = 1 + inf</code>
</p>

<p>Intentar reducir la expresión inf siempre nos va a dar como resultado una expresión más y más grande (independientemente de la estrategia de evaluación que usemos)</p>

<p>
  <code class="highlighter-rouge"> inf</code>
</p>

<ul>
  <li>aplicamos inf</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 + inf</code>
</p>

<ul>
  <li>aplicamos inf (porque + es estricta)</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 + (1 + inf)</code>
</p>

<ul>
  <li>aplicamos inf (porque + es estricta)</li>
</ul>

<p>….</p>

<p>
  <code class="highlighter-rouge"> 1 + (1 + (1 + (1 + (1 + (1 + .... + inf )))))</code>
</p>

<p>Por ende, está evaluación nunca terminaría.</p>

<p>Sabiendo que</p>

<p>
  <code class="highlighter-rouge"> fst (x,_) = x</code>
</p>

<p>Consideremos la expresión fst (0,inf)</p>

<p>Usando la estrategia call-by-value</p>

<p>
  <code class="highlighter-rouge"> fst (0,inf)</code>
</p>

<ul>
  <li>aplicamos inf</li>
</ul>

<p>
  <code class="highlighter-rouge"> fst (0, 1 + inf )</code>
</p>

<ul>
  <li>aplicamos inf</li>
</ul>

<p>
  <code class="highlighter-rouge"> fst (0, 1 + (1 + inf) )</code>
</p>

<ul>
  <li>aplicamos inf</li>
</ul>

<p>
  <code class="highlighter-rouge"> fst (0, 1 + (1 + (1 + inf) ) )</code>
</p>

<ul>
  <li>aplicamos inf</li>
</ul>

<p>…</p>

<p>Usando call-by-value la evaluación de la expresión no termina.</p>

<p>Usemos call-by-name:</p>

<p>
  <code class="highlighter-rouge"> fst (0,inf)</code>
</p>

<ul>
  <li>aplicamos fst</li>
</ul>

<p>
  <code class="highlighter-rouge"> 0</code>
</p>

<p>Usando call-by-name la expresión se evalúa por completo con solo una reducción. En este ejemplo se puede ver que ciertas expresiones que pueden no terminar cuando se evalúan con la estrategia call-by-value pueden terminar cuando se usa la estrategia call-by-name.</p>

<p>De forma más general: Si existe alguna secuencia de evaluación que haga terminar la evaluación de la expresión entonces con la estrategia call-by-name también se termina la evaluación y se produce el mismo resultado final.</p>

<p>Corolario: si te es mucho muy importante que una expresión termine la estrategia que querés usar es call-by-name</p>

<h1 id="tocAnchor-1-7">Lazy Evaluation</h1>

<h2 id="tocAnchor-1-7-1">Visión técnica</h2>

<p>Si tenemos la siguiente definición</p>

<p>
  <code class="highlighter-rouge"> alCuadrado x = x * x</code>
</p>

<p>Vamos a evaluar la expresión alCuadrado (2*3) usando call-by-value</p>

<p>
  <code class="highlighter-rouge"> alCuadrado (1+2)</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge"> alCuadrado 3</code>
</p>

<ul>
  <li>aplicamos alCuadrado</li>
</ul>

<p>
  <code class="highlighter-rouge"> 3 * 3</code>
</p>

<ul>
  <li>aplicamos *</li>
</ul>

<p>
  <code class="highlighter-rouge"> 9</code>
</p>

<p>Ahora vamos a evaluar la misma expresión usando call-by-name</p>

<p>
  <code class="highlighter-rouge"> alCuadrado (1+2)</code>
</p>

<ul>
  <li>aplicamos alCuadrado el primer +</li>
</ul>

<p>
  <code class="highlighter-rouge"> (1+2) * (1+2)</code>
</p>

<ul>
  <li>aplicamos el +</li>
</ul>

<p>
  <code class="highlighter-rouge"> 3 * (1+2)</code>
</p>

<ul>
  <li>aplicamos el *</li>
</ul>

<p>
  <code class="highlighter-rouge"> 3 * 3</code>
</p>

<ul>
  <li>aplicamos el *</li>
</ul>

<p>
  <code class="highlighter-rouge"> 9</code>
</p>

<p>Llegamos la mismo resultado pero en el segundo ejemplo realizamos una reducción más (4 reducciones vs 3 reducciones).</p>

<p>Con call-by-name la expresión (1+2) se evaluó dos veces.</p>

<p>Corolario: cuando usamos call-by-value los parámetros son evaluados una y solo una vez; cuando usamos call-by-name el mismo parámetro puede llegar a ser evaluado más de una vez.</p>

<p>Para evitar este quilombo en vez de tener la expresión (1+2) vamos a tener un “puntero a la expresión” llamémoslo p.</p>

<p>
  <code class="highlighter-rouge">alCuadrado (1+2)</code>
</p>

<ul>
  <li>aplicamos alCuadrado</li>
</ul>

<p>
  <code class="highlighter-rouge">let p = (1+2) in p * p</code>
</p>

<ul>
  <li>aplicamos +</li>
</ul>

<p>
  <code class="highlighter-rouge">let p = 3 in p * p</code>
</p>

<ul>
  <li>aplicamos *</li>
</ul>

<p>
  <code class="highlighter-rouge"> 9</code>
</p>

<p>Cualquier reducción que se haga en una expresión se va a conocer automáticamente por los punteros a dicha expresión. Al uso de punteros para compartir expresiones que representan la mismo parámetro lo vamos a llamar Sharing. Al uso de la estrategia call-by-name más el Sharing lo vamos a llamar Lazy Evaluation (esta es la estrategia que usa Haskell). El Sharing nos asegura que usar Lazy Evaluation nunca requiera más pasos que la estrategia call-by-value.</p>

<h2 id="tocAnchor-1-7-2">Visión operativa</h2>

<p>A efectos de resumir lo que vimos hasta ahora vamos a entender lo siguiente …</p>

<p><strong>Lazy Evaluation</strong>: con esta estrategia los parámetros solo se resuelven cuando son necesarios (y son evaluados solo lo necesario). También conocida como <strong>evaluación perezosa</strong> o <strong>diferida</strong>.</p>

<p>A la estrategia call-by-value (y sus variantes) también se las conoce como Eager Evaluation. <strong>Eager Evaluation</strong>: con esta estrategia los parámetros tienen que resolverse antes de aplicar la función. También conocida como <strong>evaluación ansiosa</strong>.</p>

<h2 id="tocAnchor-1-7-3">Estructuras infinitas</h2>

<p>Pensemos en la siguiente definición</p>

<p>
  <code class="highlighter-rouge">  unos = 1 : unos</code>
</p>

<p>(A partir de ahora vamos a pensar que evaluamos todo en Haskell así que la estrategia que usamos es Lazy Evaluation)</p>

<p>
  <code class="highlighter-rouge"> unos</code>
</p>

<ul>
  <li>aplicamos unos</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : unos</code>
</p>

<ul>
  <li>aplicamos unos</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : ( 1 : unos )</code>
</p>

<ul>
  <li>aplicamos unos</li>
</ul>

<p>…</p>

<p>En Haskell</p>

<p><code class="highlighter-rouge">  &gt; unos</code>
<code class="highlighter-rouge">   [1,1,1,1,1,1,1........</code></p>

<p>Como se puede ver la evaluación de unos no termina. A pesar de esto podemos usar la expresión unos dentro de nuestro programa y aplicarla a otras funciones. Por ejemplo</p>

<p>Siendo head (x:_) = x y la expresión head unos</p>

<p>
  <code class="highlighter-rouge"> head unos</code>
</p>

<ul>
  <li>deberíamos aplicar head pero como head me fuerza a tener la lista separada en cabeza:cola tenemos que evaluar unos por el pattern-matching</li>
</ul>

<p>
  <code class="highlighter-rouge"> head (1:unos)</code>
</p>

<ul>
  <li>aplicamos head</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1</code>
</p>

<p>Con este ejemplo podemos ver que unos no es una lista infinita sino potencialmente infinita, si aplicamos sobre ella funciones que no la fuerzan a evaluarse por completo la computación termina (eso sonó apocalíptico). La potencia de Lazy Evaluation está en que la expresión unos se evalúa solo lo necesario para que pueda usarla la función que la recibe como parámetro.</p>

<h2 id="tocAnchor-1-7-4">Listas infinitas</h2>

<p>Ya vimos la lista de unos que es “infinita”, ahora veamos como hacer una lista que tenga todos los números naturales</p>

<p>
  <code class="highlighter-rouge"> naturalesDesde x = x : naturalesDesde (x+1)</code>
</p>

<p><code class="highlighter-rouge"> &gt; naturalesDesde 1</code>
<code class="highlighter-rouge">   [1,2,3,4,5,6,7,8,9,...........</code></p>

<p>Haskell trae un atajo para esto</p>

<p>
  <code class="highlighter-rouge"> naturalesDesde x = [x..]</code>
</p>

<p>También sirve para hacer listas con alguna condición entre dos de sus elementos consecutivos</p>

<p><code class="highlighter-rouge"> &gt; [1,3..]</code>
<code class="highlighter-rouge">   [1,3,5,7,9,11,.........</code></p>

<p>Entonces si queremos obtener los primeros 24 múltiplos de 13 podemos hacerlo de esta forma:</p>

<p><code class="highlighter-rouge"> &gt; [13,26..24*13]</code>
<code class="highlighter-rouge">   [13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247]</code></p>

<p>Pero también podemos resolverlo con una lista infinita usando take como veremos a continuación gracias a la evaluación perezosa.</p>

<p><code class="highlighter-rouge"> &gt; take 24 [13,26..]</code>
<code class="highlighter-rouge">   [13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247]</code></p>

<h1 id="tocAnchor-1-12">Ejemplos</h1>

<p>Dada la siguiente definición de take</p>

<p><code class="highlighter-rouge"> take 0 _ = []</code>
<code class="highlighter-rouge"> take _ [] = []</code>
<code class="highlighter-rouge"> take n (x:xs) = x : (take (n-1) xs)</code></p>

<p>
  <code class="highlighter-rouge"> take 3 [1..]</code>
</p>

<ul>
  <li>aplicamos ..</li>
</ul>

<p>
  <code class="highlighter-rouge"> take 3 (1:[2..])</code>
</p>

<ul>
  <li>aplicamos take - 3ra línea</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : (take 2 [2..])</code>
</p>

<ul>
  <li>aplicamos ..</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : (take 2 (2:[3..]))</code>
</p>

<ul>
  <li>aplicamos take - 3ra línea</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : ( 2 : (take 1 [3..]))</code>
</p>

<ul>
  <li>aplicamos ..</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : ( 2 : (take 1 (3:[4..])))</code>
</p>

<ul>
  <li>aplicamos take - 3ra línea</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : ( 2 : ( 3 : (take 0 [ 4.. ]))))</code>
</p>

<ul>
  <li>aplicamos take - 1ra línea</li>
</ul>

<p>
  <code class="highlighter-rouge"> 1 : ( 2 : ( 3 : [] ))) = [1,2,3]</code>
</p>

<p>Vamos a otro ejemplo</p>

<p>
  <code class="highlighter-rouge"> take 3 [4+5,2/0,3*2]</code>
</p>

<ul>
  <li>aplicamos el + (porque dice x: en take 3ra línea)</li>
</ul>

<p>
  <code class="highlighter-rouge"> take 3 [9,2/0,3*2]</code>
</p>

<ul>
  <li>aplicamos take - 3ra línea</li>
</ul>

<p>
  <code class="highlighter-rouge"> 9 : take 2 [2/0,3*2]</code>
</p>

<ul>
  <li>aplicamos /</li>
</ul>

<p>
  <code class="highlighter-rouge"> 9 : ERROR DIVISON BY ZERO !!!</code>
</p>

<p>Dada la definición de (!!)</p>

<p><code class="highlighter-rouge">(!!) 0 (x:_) = x</code>
<code class="highlighter-rouge">(!!) n (_:xs) = (!!) (n-1) xs</code></p>

<p>
  <code class="highlighter-rouge">(!!) 2 [4+5,2/0,3*2]</code>
</p>

<ul>
  <li>aplicamos el !! (no es necesario aplicar el + porque en (!!) dice (_:xs) )</li>
</ul>

<p>
  <code class="highlighter-rouge">(!!) 1 [2/0,3*2]</code>
</p>

<ul>
  <li>aplicamos el !! (no es necesario aplicar la / por lo anterior)</li>
</ul>

<p>
  <code class="highlighter-rouge">(!!) 0 [3*2]</code>
</p>

<ul>
  <li>aplicamos * (porque la primer línea de !! lo pide)</li>
</ul>

<p>
  <code class="highlighter-rouge">(!!) 0 [6]</code>
</p>

<ul>
  <li>aplicamos !!</li>
</ul>

<p>
  <code class="highlighter-rouge">6</code>
</p>

<p>Supongamos que hacemos esta consulta:</p>

<p>
  <code class="highlighter-rouge"> &gt; head (filter (3&lt;) [1..])</code>
</p>

<p>Si bien la expresión <code class="highlighter-rouge">filter</code> <code class="highlighter-rouge">(3&lt;)</code> <code class="highlighter-rouge">[1..]</code> no termina (seguiría buscando cuáles son mayores a 3 infinitamente), como lo que primero se evalúa es el head y se difiere la ejecución del filtrado, la ejecución va a terminar en cuanto el filter encuentre su primer elemento que pertenezca a la solución que es el 4.</p>

<p>Es importante notar que en este otro caso:</p>

<p>
  <code class="highlighter-rouge"> &gt; head (filter (&lt;0) [1..])</code>
</p>

<p>La evaluación nunca termina por más que se use head que era lo que antes acotaba la ejecución, ya que nunca se va a encontrar el primer elemento que cumpla la condición a diferencia del caso anterior.</p>

</div>

<div id="article_metadata">
    <p>Latest update on February 02, 2017 by
        Ernesto Bossi</p>

    <ul class="accordion" data-accordion>
        <li class="accordion-navigation">
            <a href="#panel1a">Page History, Meta information</a>

            <div id="panel1a" class="content">

                <div class="rows">
                    <div class="column small-12 medium-6 large-6">
                        <table>
                            <thead>
                            <tr>
                                <th>Page Commits</th>
                                <th>Page Additions</th>
                                <th>Page Deletions</th>
                            </tr>
                            </thead>

                            <tbody>
                            <tr>
                                <td>2</td>
                                <td>472</td>
                                <td>0</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="column small-12 medium-6 large-6">
                        <table>
                            <thead>
                            <tr>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Commits</th>
                            <tr>
                            </thead>

                            <tbody>
                            
                            <tr>
                                <td>Ernesto Bossi</td>
                                <td>bossi.e...</td>
                                <td>1</td>
                            </tr>
                            
                            <tr>
                                <td>Npasserini</td>
                                <td>Npasser...</td>
                                <td>1</td>
                            </tr>
                            
                            </tbody>
                        </table>
                    </div>
                </div>

                <table style="margin-left: 15px;">
                    <thead>
                    <tr>
                        <th>Hash</th>
                        <th>Time</th>
                        <th>Name</th>
                        <th>Mail</th>
                        <th>Subject</th>
                    <tr>
                    </thead>

                    <tbody>
                    
                    <tr>
                        <td>bef5aba</td>
                        <td>Thu Feb 2 19:24:04 2017 -0300</td>
                        <td>Ernesto Bossi</td>
                        <td>bossi.e...</td>
                        <td>build up initial migration with old commits</td>
                    </tr>
                    
                    <tr>
                        <td>299a477</td>
                        <td>Thu Feb 2 19:14:20 2017 -0300</td>
                        <td>Ernesto Bossi</td>
                        <td>bossi.e...</td>
                        <td>/* ¿Por qué entonces dice unexpected `;', si yo no puse ningún ";"? */</td>
                    </tr>
                    
                    </tbody>
                </table>

            </div>
        </li>
    </ul>

</div>


</div>


<div id="footer">
    <div class="columns small-1 medium-2 large-3">
        <small>(C) 2015-17 Matthias Beyer/Ernesto Bossi</small>
    </div>

    <div class="columns small-11 medium-10 large-9">
    </div>

</div>

<script>
    'use strict';
</script>

<script src="/wiki/assets/jquery-9954088f87089c387789507249fa70d3.js"></script>
<script src="/wiki/assets/jquery.min-650c8b3af3d010ec559014c6e70b13c3.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js" type="text/javascript"></script>

<script src="/wiki/assets/foundation/foundation-8e0f071884576348dba555b27a4bcaa9.js"></script>
<script src="/wiki/assets/foundation/foundation.abide-fa5ce9fbf8301ae49154ebc752edc220.js"></script>
<script src="/wiki/assets/foundation/foundation.accordion-bcc423fb0c2a3d515ba85ff591171a8e.js"></script>
<script src="/wiki/assets/foundation/foundation.alert-609b779b55610f4916250faaa37d1cfc.js"></script>
<script src="/wiki/assets/foundation/foundation.clearing-167db0285c7a789f7f216183f9038ac4.js"></script>
<script src="/wiki/assets/foundation/foundation.dropdown-25aac997ca0ca5dc3c3094c266c8f5aa.js"></script>
<script src="/wiki/assets/foundation/foundation.equalizer-cbdd8079a6f777c37dd1314f9b17faec.js"></script>
<script src="/wiki/assets/foundation/foundation.interchange-6ef75863aff8abeff4de79554b62e1b9.js"></script>
<script src="/wiki/assets/foundation/foundation.joyride-7cce0075f55d456449419a92671a3874.js"></script>
<script src="/wiki/assets/foundation/foundation.magellan-dc0647982e238cf1db3113e50d1b85dd.js"></script>
<script src="/wiki/assets/foundation/foundation.offcanvas-61dc0fe57ed932800c4a09b92c1ba4e5.js"></script>
<script src="/wiki/assets/foundation/foundation.orbit-9698da4fd068f7b83b3e5c00aae63ab3.js"></script>
<script src="/wiki/assets/foundation/foundation.reveal-4944447a204c398659229cfd716786a1.js"></script>
<script src="/wiki/assets/foundation/foundation.slider-7ea4b29f663e7e1b52ddc9f7ca0458b3.js"></script>
<script src="/wiki/assets/foundation/foundation.tab-c2efa8f5f8b255b06db277c3f339a0c7.js"></script>
<script src="/wiki/assets/foundation/foundation.tooltip-4a5d212b8f811ff50bba6cc61a2b899a.js"></script>
<script src="/wiki/assets/foundation/foundation.topbar-4dd840d30430ff2146208830574ca615.js"></script>

<script src="/wiki/assets/jquery.cookie-61d99d4505fb2f5359bf351153c83f1d.js"></script>
<!-- Script pointing to jekyll-search.js -->
<script src="/wiki/assets/jekyll-search-2c27791d765f338cd196c9aa9a050936.js"></script>

<script>
    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: "/wiki/search.json"
    });

    $(document).foundation();

</script>

<!-- prism.js -->
<script src="/wiki/assets/prism-1eea551ba45e704ef55167430bb80ce4.js"></script>
</body>
</html>
